#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_GOOGLE_include_directive : enable

#include "definitions.glsl"
#include "random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties {
    mat4 viewInverse;
    mat4 projInverse;
    uint framesSinceMoved;
    uint randomSeed;
}
cameraProperties;

layout(location = ColorPayloadIndex) rayPayloadEXT RayPayload rayPayload;

// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl/148088#148088
vec3 linearToSRGB(vec3 linear) {
    bvec3 cutoff = lessThan(linear, vec3(0.0031308));
    vec3 higher = vec3(1.055) * pow(linear, vec3(1.0 / 2.4)) - vec3(0.055);
    vec3 lower = linear * vec3(12.92);

    return mix(higher, lower, cutoff);
}

vec3 srgbToLinear(vec3 sRGB) {
    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));
    vec3 higher = pow((sRGB + vec3(0.055)) / vec3(1.055), vec3(2.4));
    vec3 lower = sRGB / vec3(12.92);

    return mix(higher, lower, cutoff);
}

void main() {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 uv = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    const vec2 d = uv * 2.0 - 1.0;

    vec3 accumulatedRadiance = vec3(0.0f);
    uint randomSeed = cameraProperties.randomSeed;
    float sampleWeight = 1 / float(RaysPerPixel);

    const vec3 viewOrigin = (cameraProperties.viewInverse * vec4(0, 0, 0, 1)).xyz;
    const vec4 target = cameraProperties.projInverse * vec4(d.x, d.y, 1, 1);
    const vec3 viewDirection = (cameraProperties.viewInverse * vec4(normalize(target.xyz), 0)).xyz;

    for (uint i = 0; i < RaysPerPixel; i += 1) {
        vec3 origin = viewOrigin;
        vec3 direction = viewDirection;
        
        rayPayload.depth = 0;
        rayPayload.radiance = vec3(0.0f);
        rayPayload.color = vec3(1.0f);
        rayPayload.randomSeed = random(randomSeed);
        rayPayload.pixelUV = uv;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            AllMask,
            DefaultSBTOffset,
            DefaultSBTStride,
            ColorMissIndex,
            origin,
            TMin,
            direction,
            TMax,
            ColorPayloadIndex);

        accumulatedRadiance += rayPayload.radiance * sampleWeight;
    }
    accumulatedRadiance = accumulatedRadiance / (accumulatedRadiance + vec3(1.0));
    float hysteresisFactor = 1.0f / (cameraProperties.framesSinceMoved + 1);
    const vec3 previousFrameLight = srgbToLinear(imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb);
    vec3 finalColor = mix(previousFrameLight, accumulatedRadiance, hysteresisFactor);
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(linearToSRGB(finalColor), 0.0));
}
